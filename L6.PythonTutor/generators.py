# Генераторы для:
# - списков []
# - множеств {}
# - словарей {}
# -------- не для кортежей (1,) !!!!!!!!!

# Для создания списков, заполненных по более сложным формулам можно использовать генераторы:
# выражения, позволяющие заполнить список некоторой формулой. Общий вид генератора следующий:
#
# [выражение for переменная in последовательность]
#
# где переменная — идентификатор некоторой переменной,
# последовательность — последовательность значений, который принимает данная переменная
# (это может быть список, строка или объект, полученный при помощи функции range),
# выражение — некоторое выражение, как правило, зависящее от использованной в генераторе переменной,
# которым будут заполнены элементы списка.

#Генерация списков
#
#res = []
#for x in range(1, 25, 2):
#    res.append(x)
print('Генерация списков')
res = [x for x in range(1, 25, 2)]
print(res)

#список квадратов тех же нечетных чисел:
res = [x**2 for x in range(1, 25, 2)]
print(res)

# Создать список, состоящий из n нулей можно и при помощи генератора:
a = [0 for i in range(5)]
print(a)

# Создать список, заполненный квадратами целых чисел
n = 5
a = [i ** 2 for i in range(n)]
print(a)

# получить список, заполненный случайными числами от 1 до 9 (используя функцию randrange из модуля random)
from random import randrange
n = 10
a = [randrange(1, 10) for i in range(n)]
print(a)

# можно добавить дополнительные условия фильтрации.
# Например, доработаем наш предыдущий пример так, чтобы исключались квадраты чисел, кратных 3.

res = [x**2 for x in range(1, 25, 2) if x % 3 != 0]
print(res)

# Генератор списков - способ построить новый список, применяя выражение к каждому элементу последовательности.
c = [c * 3 for c in 'list']
print(c)

# более сложная конструкция генератора списков:
c = [c * 3 for c in 'list' if c != 'i']
print(c)
c = [c + d for c in 'list' if c != 'i' for d in 'spam' if d != 'a']
print(c)

#list generater с вводом данных
print('generater с вводом данных')
# a = [int(s) for s in input('number with space: ').split()]
a = [int(s) for s in '12 3 45 6 66 77 88 '.split()]
print(a)
print()

# Вложенные генераторы двумерных массивов
# сделать список из n строк и m столбцов можно при помощи генератора,
# создающего список из n элементов, каждый элемент которого является списком из m нулей:
print('Вложенные генераторы двумерных массивов')
m = 3
n = 6
a = [[0] * m for i in range(n)]
print(a)
print()
# Но при этом внутренний список также можно создать при помощи,
# например, такого генератора: [0 for j in range(m)].
# Вложив один генератор в другой, получим вложенные генераторы:
print('внутренний список - генератор: [0 for j in range(m)]')
m = 5
n = 8
a = [[0 for j in range(m)] for i in range(n)]
print(a)
print()

# если число 0 заменить на некоторое выражение,
# зависящее от i (номер строки) и j (номер столбца),
# то можно получить список, заполненный по некоторой формуле.
print('список, заполненный по некоторой формуле')
m = 5
n = 8
a = [[i * j for j in range(m)] for i in range(n)]
print(a)
print()

a = [1, 2, 3, 4, 5, 6]
b = {}
for i in range(0, len(a) - 1, 2):
    b[a[i]] = a[i+1]

print(b)
b = {a[i]: a[i+1] for i in range(0, len(a) - 1, 2)}
print(b)

col2 = [row[1] for row in M] # Выбирает элементы второго столбца
генераторы списков могут приобретать еще более сложную форму:
>>> [row[1] + 1 for row in M] # Добавить 1 к каждому элементу в столбце 2
>>> [row[1] for row in M if row[1] % 2 == 0] # отфильтровать нечетные значения


в последних версиях Python��������������������
��������������������������
можно также исполь-
зовать конструкции генераторов списков, заключенные в круглые скобки, для
создания генераторов, которые воспроизводят результаты по требованию. На-
пример, ниже показано, как с помощью встроенной функции sum можно сум-
мировать элементы в последовательности:
>>> G = (sum(row) for row in M) # Генератор, возвращающий суммы элементов строк
>>> next(G)
6
>>> next(G)
# Вызов в соответствии с протоколом итераций
15
Того же эффекта можно добиться с  помощью встроенной функции map, гене-
рируя результаты за счет передачи элементов другой функции. Обертывание
вызова этой функции в список (в версии Python 3.0) вынуждает ее вернуть все
значения:
>>> list(map(sum, M)) # Отобразить sum на элементы в M
[6, 15, 24]
В Python 3.0 синтаксис генераторов списков может также использоваться для
создания множеств и словарей:
>>> {sum(row) for row in M}
# Создаст множество сумм строк
{24, 6, 15}
>>> {i : sum(M[i]) for i in range(3)} # Таблица пар ключ/значение сумм строк
{0: 6, 1: 15, 2: 24}
Фактически в версии 3.0 с помощью подобных выражений-генераторов можно
создавать списки, множества и словари:
>>> [ord(x) for x in ‘spaam’]
#
[115, 112, 97, 97, 109]
>>> {ord(x) for x in ‘spaam’}
#
{112, 97, 115, 109}
>>> {x: ord(x) for x in ‘spaam’} #
{‘a’: 97, ‘p’: 112, ‘s’: 115, ‘m’:
Список кодов символов
Множества ликвидируют дубликаты
Ключи словарей являются уникальными
109}

# create dictionary
d = {key: value for key in keys for value in values}
d=dict(**kwargs)
#d= dict(mapping, **kwargs)
#d = dict(iterable, **kwargs)